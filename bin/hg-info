#!/usr/bin/env python3
"""
Get repository information
"""
import subprocess, getopt, os, sys, re

dump_commands = False # Whether to display executed commands.

# {{{ Vcs classes
class Vcs:
    def __init__(self, default_path, default_branch):
        self.path = default_path
        self.vcs_default_branch = default_branch
        self.default_branch = default_branch

    def set_path(self, path):
        self.path = path

    def set_defaut_branch(self, default_branch):
        if not default_branch:
            default_branch = self.vcs_default_branch
        self.default_branch = default_branch

    def get_numeric(self):
        raise NotImplementedError("Implement me in " + str(repr(self)))

    def get_modified(self):
        raise NotImplementedError("Implement me in " + str(repr(self)))

    def get_branch(self):
        raise NotImplementedError("Implement me in " + str(repr(self)))

    def get_tags(self):
        raise NotImplementedError("Implement me in " + str(repr(self)))


class HgVcs(Vcs):
    def __init__(self):
        super().__init__("hg", "default")
        self.numeric = None # Some unique-ish number.
        self.modified = None # 'M' if modified.
        self.branch = None # branch name
        self.tags = None # tag, list str

    def private_get_info(self):
        cmd = [self.path, 'id', '-n', '-b', '-t']
        lines = exe_cmd(cmd, {'HGPLAIN': ''})

        assert len(lines) == 1
        words = lines[0].split()
        numeric = words[0]
        self.branch = words[1]
        self.tags = [w for w in words[2:] if w != 'tip']

        if numeric[-1] == '+':
            self.numeric = numeric[:-1]
            self.modified = 'M'
        else:
            self.numeric = numeric
            self.modified = ''

    def get_numeric(self):
        if self.numeric is None:
            self.private_get_info()
        return self.numeric

    def get_modified(self):
        if self.modified is None:
            self.private_get_info()
        return self.modified

    def get_branch(self):
        if self.branch is None:
            self.private_get_info()
        return self.branch

    def get_tags(self):
        if self.tags is None:
            self.private_get_info()
        return self.tags

GIT_COMMIT_PAT = re.compile('# branch.oid +(.*)')
GIT_CURBRANCH_PAT = re.compile('# branch.head +(.*)')

class GitVcs(Vcs):
    def __init__(self):
        super().__init__("git", "master")
        self.numeric = None # Some unique-ish number.
        self.modified = None # 'M' if modified.
        self.branch = None # branch name

    def private_get_status(self):
        self.modified = False

        # https://git-scm.com/docs/git-status
        cmd = [self.path, "status", "--porcelain=2", "--branch"]
        for line in exe_cmd(cmd):
            if line and line[0] in ("1", "2", "u"):
                self.modified = True
                continue
            m = GIT_COMMIT_PAT.match(line)
            if m:
                self.numeric = m.group(1).strip()
                continue
            m = GIT_CURBRANCH_PAT.match(line)
            if m:
                self.branch = m.group(1).strip()
                continue
        assert self.numeric is not None
        assert self.branch is not None

    def get_numeric(self):
        if self.numeric is None:
            self.private_get_status()
        return self.numeric

    def get_modified(self):
        if self.modified is None:
            self.private_get_status()
        return self.modified

    def get_branch(self):
        if self.branch is None:
            self.private_get_status()
        return self.branch

    def get_tags(self):
        # Are tags useful at all?
        return []

# }}}
# {{{ Version number output options
class OutputOption:
    def __init__(self, name, desc):
        self.name = name
        self.desc = desc

    def compute(self, vcs):
        raise NotImplementedError("Implement me in " + str(repr(self)))


def make_branch_name(branch, default_branch):
    if branch == default_branch:
        return ''
    return branch


class OutputIdModified(OutputOption):
    def __init__(self):
        super().__init__("id-modified",
                         "Output numeric id, 'M' appended if source is modified")

    def compute(self, vcs):
        return vcs.get_numeric() + vcs.get_modified()


class OutputNumericId(OutputOption):
    def __init__(self):
        super().__init__("num-id",
                         "Output numeric id without modification indication")

    def compute(self, vcs):
        return vcs.get_numeric()


class OutputBranch(OutputOption):
    def __init__(self):
        super().__init__("branch",
                         "Output branch, empty string if default branch")

    def compute(self, vcs):
        return make_branch_name(vcs.get_branch(), vcs.default_branch)

class OutputVersion(OutputOption):
    def __init__(self):
        super().__init__("version",
                         "Output version indication, for appending to grf name")

    def compute(self, vcs):
        tags = vcs.get_tags()
        if len(tags) > 0:
            return "{}{}".format(tags[0], vcs.get_modified())

        branch = make_branch_name(vcs.get_branch(), vcs.default_branch)
        if branch == '':
            return "r{}{}".format(vcs.get_numeric(), vcs.get_modified())
        return "{}-r{}{}".format(branch, vcs.get_numeric(), vcs.get_modified())

OUTPUT_OPTS = [ OutputIdModified(), OutputNumericId(), OutputBranch(),
                OutputVersion() ]
OUTPUT_OPTS_BY_NAME = dict((opt.name, opt) for opt in OUTPUT_OPTS)
# }}}

def escape_name(text):
    """
    Make the text reasonably safe to use at the command line.
    """
    if len(text) == 0:
        return '""' # Empty arguments should not disappear.

    # ('look for', 'replace by', 'do replace') triplets
    replacements = [('\\', '\\\\', True), (' ', '\\ ', False), ('!', '\\!', True),
                    ('&', '\\&', True), ('[', '\\[', True), ('"', '\\"', True) ]

    safe = True
    for repl in replacements:
        if repl[0] in text:
            safe = False
            break

    if safe:
        return text # Already safe by itself

    # Apply replacements to make the text safe.
    for repl in replacements:
        if repl[2]:
            text = text.replace(repl[0], repl[1])
    return '"' + text + '"'

def exe_cmd(cmd, env=None):
    """
    Execute a shell command.

    @param cmd: List of command-line arguments.
    @param env: Environment variables to set (dict of key/value pairs)
    @return: Lines of output.
    @note: If command fails, program is aborted.
    """
    if dump_commands:
        print("CMD: {}".format(" ".join(escape_name(arg) for arg in cmd)))

    if env is not None:
        new_env = os.environ.copy()
        new_env.update(env)
    else:
        new_env = None

    if sys.version_info.minor < 5:
        # Pre 3.5 has no subprocess.run
        output = subprocess.check_output(cmd, env=new_env, universal_newlines=True)
    else:
        output = subprocess.run(cmd, env=new_env, check=True, stdout=subprocess.PIPE,
                                universal_newlines=True).stdout

    lines = output.splitlines()
    return lines


def compute_outputs(output_names, vcs):
    """
    Compute all requested output texts.
    """
    outputs = []
    for name in output_names:
        output_opt = OUTPUT_OPTS_BY_NAME[name]
        outputs.append(output_opt.compute(vcs))

    return outputs


def print_opts(opts):
    """
    Output the options as an indented 2-column text.
    """
    optmax = max(len(opt[0]) for opt in opts)
    for optname, optdesc in opts:
        spaces = " " * (2 + optmax - len(optname))
        print("  {}{}{}".format(optname, spaces, optdesc))


def usage():
    print("Usage: hg-info [options]")
    print("Extracts repository information, and builds branch and version suffixes from it")

    print("Options (settings):")
    opts = [("-h, --help", "This online help"),
            ("-v, --verbose", "Dump executed commands to the output"),
            ("--use-hg", "Use Mercurial as version control system"),
            ("--use-git", "Use Git as version control system"),
            ("-m HG, --mercurial=HG",
             "Path to the 'hg' binary, default is 'hg'"),
            ("-g GIT, --git=GIT",
             "Path to the 'git' binary, default is 'git'"),
            ("-b BRANCH",
             "Name of the default branch"), ]
    for output_opt in sorted(OUTPUT_OPTS_BY_NAME.items()):
        opts.append(("--" + output_opt[1].name, output_opt[1].desc))
    print_opts(opts)

    print("")
    print("Output is a single line with all output requests in the same order")
    print("")
    print("In a GNU Makefile, splitting the output can be done like")
    print("  REPO_INFO = $(shell $(HG_INFO) --num-id --version)")
    print("  REPO_REVISION = $(word 1,$(REPO_INFO))")
    print("  REPO_VERSION = $(word 2,$(REPO_INFO))")

def run():
    global dump_commands

    short_opts = 'hvb:g:'
    long_opts = (['help', "verbose", "git=", "use-hg", "use-git",
                  "mercurial=", "grf="] +
                 list(OUTPUT_OPTS_BY_NAME.keys()))

    try:
        opts, args = getopt.getopt(sys.argv[1:], short_opts, long_opts)
    except getopt.GetoptError as ex:
        print("hg-info ERROR: {}".format(ex))
        sys.exit(1)

    if len(args) > 0:
        print("hg-info ERROR: Command does not accept arguments")
        sys.exit(1)

    hg_vcs = HgVcs()
    git_vcs = GitVcs()

    used_vcs = None
    grf_name = None
    output_names = []
    for opt, opt_val in opts:
        if opt in ('-h', '--help'):
            usage()
            sys.exit(0)

        if opt in ('-g', '--grf'):
            grf_name = optval
            continue

        if opt in ('-v', '--verbose'):
            dump_commands = True
            continue

        if opt == '--mercurial':
            hg_vcs.set_path(opt_val)
            continue

        if opt == '--git':
            git_vcs.set_path(opt_val)
            continue

        if opt == "--use-hg":
            used_vcs = hg_vcs
            continue

        if opt == "--use-git":
            used_vcs = git_vcs
            continue

        if opt == '-b':
            hg_vcs.set_defaut_branch(opt_val)
            continue

        if opt.startswith("--") and opt[2:] in OUTPUT_OPTS_BY_NAME:
            output_names.append(opt[2:])
            continue

        assert False, "Unexpected option value {}".format((opt, opt_val))

    if used_vcs is None:
        # TODO: Automagic detection of the vcs
        print("hg-info ERROR: No version control system selected")
        sys.exit(1)

    outputs = compute_outputs(output_names, used_vcs)
    print("{}".format(" ".join(escape_name(out) for out in outputs)))
    sys.exit(0)

if __name__ == '__main__':
    run()
